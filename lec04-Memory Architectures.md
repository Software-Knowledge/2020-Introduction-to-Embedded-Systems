lec04-Memory Architectures
---
# 1. 内存
1. 内存不断增长
2. 以16K开头的PC：最大：640K、当前的4G规范
3. 地址总线的大小？32位不足、64位是可以的、128位有点浪费

# 2. 什么是内存?

## 2.1. 硬件工程师的角度
内存是一种可以保留数据位的芯片，实际上有两种：ROM和RAM。这些依次又分为两种。有带掩膜的已编程ROM和可编程设备，您可以自己编程。RAM可能是静态的，易于使用，但容量较小；动态更密集，但需要支持电路。

## 2.2. 软件工程师的角度
内存是您运行程序的地方。将代码和数据从磁盘上读取到内存中，并执行程序。您不必太担心大小，因为虚拟内存实际上是无限的。

## 2.3. 嵌入式工程师的角度
内存分为两种：ROM，用于保存代码和常量；以及RAM，用于保存变量数据(但其中包含启动时的垃圾)。

## 2.4. C程序员的角度
内存的种类很多：代码，变量数据，文字，字符串常量，初始化的静态变量，未初始化的静态变量，堆栈，堆，一些真正的I/O设备等等。

# 3. 可固化代码
1. 代码将从ROM正确执行：无需复制到RAM，但是RAM会快一些
2. 代码和数据是不可以混合的：期待是静态的数据
3. 编译器/链接器应符合这些要求:相对比较高
4. XIP:eXecute In Place

# 4. 内存组件
1. 几种不同类型的内存：DRAM、SRAM、Flash、MRAM(磁读RAM，物联网推动发展)、PCRAM、ReRAM
2. 每种类型的内存都各不相同：
   1. 容量
   2. 带宽(下图中的Memory array中的:thumb指令，传递次数)

![](img/lec4/1.png)

## 4.1. 随机存取存储器
1. 动态RAM密集，需要刷新。
   1. 同步DRAM是主要类型。
   2. SDRAM使用时钟来提高性能，以流水线方式访问存储器。
2. 静态RAM更快，密度更低，消耗更多功率。

## 4.2. 只读内存
1. ROM可以在工厂编程。
2. 闪存是现场可编程ROM的主要形式。
   1. 电可擦除，必须块擦除。
   2. 随机访问，但是写入/擦除比读取慢得多。
   3. NOR闪存更加灵活。
   4. NAND闪存更密集。

## 4.3. 闪存
1. 非易失性存储器：闪光灯可以在线编程。
2. 随机访问以供读取。
3. 来写：
   1. 将块擦除为1。
   2. 将位写入0。

### 4.3.1. 闪存写入
1. 写比读慢得多：写1.6μs，读70 ns。
2. 块很大（大约1 Mb）。
3. 写入会导致磨损，最终损坏设备：现代寿命约一百万次写入。

### 4.3.2. 闪存类型
1. NOR:(放置固态代码:因为还有XIP)
   1. 字可读取。
   2. 逐块擦除。
2. NAND:
   1. 按页读取（512-4K字节）。
   2. 逐块擦除。
3. NAND便宜，擦除速度更快，顺序访问时间更短。

### 4.3.3. NOR和NAND闪存之间的区别
![](img/lec4/2.png)

## 4.4. 内存架构
1. 平面单空间
2. 分段式
3. 组切换
4. 多类型存储区
5. 虚拟内存

| 平面单空间内存      | 分段内存            |
| ------------------- | ------------------- |
| ![](img/lec4/3.png) | ![](img/lec4/4.png) |
| 组切换内存          | 多空间内存 |
| ![](img/lec4/5.png) | ![](img/lec4/6.png) |

### 4.4.1. 平面单空间内存
1. 简单
2. 示例：68K，Z80
3. 空间可能不连续
4. Assumed by C
5. 关心零地址

### 4.4.2. 分段内存
1. 地址空间增加
2. 示例：Intel x86
3. 2部分地址：段、偏移
4. 需要C扩展名：近和远

### 4.4.3. 组切换内存
1. 可以添加到任何处理器
2. 进入更大地址空间的窗口
3. 链接器支持有用

### 4.4.4. 多空间内存
1. 示例：68K选件，8051
2. 可能需要C语言扩展

### 4.4.5. 虚拟内存
1. 增加表观内存大小
2. 交换磁盘上的数据
3. 不是实时的
4. 增加了不确定性

### 4.4.6. 快存
1. 并不是严格的内存架构
2. 可能经常被程序员忽略
3. 优化有效使用的关键

![](img/lec4/7.png)

## 4.5. Cache操作
1. 许多主内存位置被映射到一个高速缓存条目。
2. 可能具有以下内容的缓存：
   1. 说明
   2. 数据
   3. 数据 + 说明（统一）
3. 内存访问时间不再确定。

### 4.5.1. 词
1. Cache hit: 所需的位置在缓存中。
2. Cache miss: 所需的位置不在缓存中。
3. Working set: 程序在一个时间间隔中使用的一组位置。

### 4.5.2. 内存系统性能
1. h = cache命中率.
2. $t_{cache}$ = 缓存访问时间, $t_{main}$ = 主存储器访问时间.
3. 平均内存访问时间:$t_{av} = ht_{cache} + (1-h)t_{main}$
4. 一般真正使用作为衡量的是系统最坏情况

### 4.5.3. 多级缓存访问时间
1. $h_1$ = 缓存命中率。
2. $h_2$ = L2的命中率。
3. 平均内存访问时间:$t_{av} = h_1t_{L1} + h_2t_{L2} + (1- h_2 - h_1)t_{main}$

### 4.5.4. 更换政策
1. 替换策略：选择要丢弃的缓存条目以为新的内存位置腾出空间的策略。
2. 两种流行的策略：
   1. 随机访存
   2. 最少最近使用（LRU）。

### 4.5.5. 缓存性能优势
1. 将经常访问的位置保存在快速缓存中。
2. 高速缓存一次检索多个单词：首次访问后顺序访问速度更快.

### 4.5.6. 内存管理单元
- 内存管理单元（MMU）转换地址：

![](img/lec4/8.png)

### 4.5.7. 内存管理任务
1. 允许程序在执行期间在物理内存中移动。
2. 允许虚拟内存：
   1. 存储器映像保存在二级存储器中；
   2. 图像在执行期间按需返回到主存储器。
3. 页面错误：请求的位置不驻留在内存中。

### 4.5.8. 内存管理单元
1. 主要是32位处理器
2. 可以是内置的或可选的
3. 提供内存保护
4. 通常由RTOS管理
5. 2种方法
   1. 阻塞[写保护]存储区
   2. 流程模型实施